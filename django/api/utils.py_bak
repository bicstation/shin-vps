import json
import re
from datetime import datetime
from django.db import transaction, IntegrityError
from django.db.models import Model
from django.utils.dateparse import parse_date
import hashlib
import unicodedata
import logging

# ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from api.models import RawApiData, AdultProduct, Maker, Label, Genre, Actress, Director, Series
from api.models.pc_products import PCProduct  # ðŸ’¡ PCProductã‚’è¿½åŠ 

# ãƒ­ã‚¬ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
logger = logging.getLogger('api_utils')
logger.setLevel(logging.DEBUG) 

# --------------------------------------------------------------------------
# 0. å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
# --------------------------------------------------------------------------

def generate_product_unique_id(api_source: str, api_product_id: str) -> str:
    """APIã‚½ãƒ¼ã‚¹ã¨å•†å“IDã‹ã‚‰ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ç”Ÿæˆã™ã‚‹"""
    return f"{api_source}-{api_product_id}"

# --------------------------------------------------------------------------
# 1. RawApiDataã®ä¸€æ‹¬æŒ¿å…¥ãƒ»æ›´æ–°
# --------------------------------------------------------------------------

def bulk_insert_or_update(model_name: str, batch: list):
    """
    æŒ‡å®šã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã«å¯¾ã—ã¦ã€ä¸€æ‹¬ã§æŒ¿å…¥ã¾ãŸã¯æ›´æ–°ã‚’è¡Œã„ã¾ã™ã€‚ï¼ˆRawApiDataãƒ¢ãƒ‡ãƒ«å°‚ç”¨ï¼‰
    """
    if not batch:
        return

    Model = RawApiData
    update_fields = ['raw_json_data', 'api_service', 'api_floor', 'updated_at']
    unique_fields = ['api_source', 'api_product_id'] 

    try:
        with transaction.atomic():
            Model.objects.bulk_create(
                [Model(**data) for data in batch],
                update_conflicts=True,
                unique_fields=unique_fields,
                update_fields=update_fields,
            )
    except Exception as e:
        logger.error(f"RawApiDataã®bulk_create/updateä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: {e}")


# --------------------------------------------------------------------------
# 2. ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®å–å¾—ã¾ãŸã¯ä½œæˆ
# --------------------------------------------------------------------------

def get_or_create_entity(model: type[Model], api_source: str, name: str, api_id: str | None = None) -> int | None:
    """
    ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆMaker, Genreãªã©ï¼‰ã‚’å–å¾—ã¾ãŸã¯ä½œæˆã—ã€ãã®ãƒ—ãƒ©ã‚¤ãƒžãƒªã‚­ãƒ¼ï¼ˆIDï¼‰ã‚’è¿”ã™ã€‚
    """
    if not name or not api_source:
        return None
    
    api_id_to_use = api_id
    if model is Genre and api_id is None:
        api_id_to_use = hashlib.md5(name.encode('utf-8')).hexdigest()
        
    try:
        with transaction.atomic():
            entity, created = model.objects.get_or_create(
                api_source=api_source,
                name=name,
                defaults={
                    'api_id': api_id_to_use,
                }
            )
            if created:
                logger.info(f"[{api_source}:{model.__name__}] æ–°è¦ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ä½œæˆ: {name}")
                
            return entity.id
            
    except IntegrityError:
        logger.warning(f"[{api_source}:{model.__name__}] Integrity ErrorãŒç™ºç”Ÿ (åå‰: {name})ã€‚")
        return None
    except Exception as e:
        logger.error(f"[{api_source}:{model.__name__}] ã‚¨ãƒ©ãƒ¼: {e}")
        return None


# --------------------------------------------------------------------------
# 3. PCè£½å“ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (NEW)
# --------------------------------------------------------------------------

def normalize_pc_data(row: dict, site_prefix: str = 'acer') -> dict:
    """
    CSVã®1è¡Œåˆ†ã‚’PCProductãƒ¢ãƒ‡ãƒ«ã®å½¢å¼ã«æ­£è¦åŒ–ã™ã‚‹ã€‚
    """
    image_url = row.get('image_url', '')
    
    # JANã‚³ãƒ¼ãƒ‰æŠ½å‡º (JAN-13æ¡ ã¾ãŸã¯ 45/49é–‹å§‹ã®13æ¡)
    jan_match = re.search(r'JAN-(\d{13})', image_url)
    if not jan_match:
        jan_match = re.search(r'(4[59]\d{11})', image_url)

    if jan_match:
        u_id = jan_match.group(1)
    else:
        # JANãŒãªã„å ´åˆã¯URLã®æœ«å°¾ã‚’IDã«ã™ã‚‹
        u_id = row.get('url', '').strip('/').split('/')[-1]

    # ä¾¡æ ¼ã®ã‚¯ãƒ¬ãƒ³ã‚¸ãƒ³ã‚°
    raw_price = row.get('price', '0')
    clean_price = int(''.join(filter(str.isdigit, str(raw_price)))) if raw_price else 0

    return {
        'unique_id': u_id,
        'site_prefix': site_prefix,
        'maker': 'Acer' if site_prefix == 'acer' else row.get('maker', 'Unknown'),
        'name': row.get('name', 'No Name'),
        'price': clean_price,
        'url': row.get('url', ''),
        'image_url': image_url,
        'description': row.get('description', ''),
        'genre': 'laptop',
        'is_active': True,
        'updated_at': datetime.now(),
    }


# --------------------------------------------------------------------------
# 4. DUGA API ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
# --------------------------------------------------------------------------

def normalize_duga_data(raw_data_instance: RawApiData) -> tuple[list[dict], list[dict]]:
    raw_data = raw_data_instance.raw_json_data
    try:
        if isinstance(raw_data, str):
            data = json.loads(raw_data)
        else:
            data = raw_data
    except Exception as e:
        logger.error(f"Raw ID {raw_data_instance.id} DUGAãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: {e}") 
        return [], []

    api_product_id = data.get('productid')
    if not api_product_id:
        return [], []
        
    product_id_unique = generate_product_unique_id('DUGA', api_product_id)
    release_date = parse_date(data.get('date', '').replace('/', '-'))
    
    image_url_list = []
    main_image_url_raw = data.get('image_url') or data.get('posterimage') or data.get('jacketimage')
    main_image_url = None
    
    if isinstance(main_image_url_raw, list) and main_image_url_raw:
        image_entry = main_image_url_raw[0]
        if isinstance(image_entry, dict):
            main_image_url = image_entry.get('image') or image_entry.get('large')
        elif isinstance(image_entry, str):
            main_image_url = image_entry
    elif isinstance(main_image_url_raw, str):
        main_image_url = main_image_url_raw
    
    if main_image_url and isinstance(main_image_url, str):
        image_url_list.append(main_image_url)

    raw_price = data.get('price')
    price = int("".join(filter(str.isdigit, str(raw_price)))) if raw_price else None
    title = data.get('title', 'ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜Ž')
    
    maker_id = get_or_create_entity(Maker, 'DUGA', data.get('makername'))
    
    genre_ids = []
    genre_info = data.get('category')
    if isinstance(genre_info, list):
        for item in genre_info:
            if isinstance(item, dict):
                name = item.get('data', {}).get('name') or item.get('name')
                gid = get_or_create_entity(Genre, 'DUGA', name)
                if gid: genre_ids.append(gid)
            
    actress_ids = []
    performer_str = data.get('performer_name')
    if performer_str and isinstance(performer_str, str):
        names = [p.strip() for p in performer_str.split(',') if p.strip()]
        for name in names:
            aid = get_or_create_entity(Actress, 'DUGA', name)
            if aid: actress_ids.append(aid)

    image_url_json = json.dumps(image_url_list) if image_url_list else "[]"
        
    product_data = {
        'raw_data_id': raw_data_instance.id, 
        'api_source': 'DUGA',
        'product_id_unique': product_id_unique,
        'title': title,
        'release_date': release_date,
        'affiliate_url': data.get('affiliateurl') or data.get('url') or "",
        'price': price,
        'image_url_list': image_url_json,
        'maker_id': maker_id, 
        'label_id': None,
        'director_id': None,
        'updated_at': datetime.now(), 
    }
    
    relations_data = {
        'api_product_id': api_product_id,
        'genre_ids': genre_ids,
        'actress_ids': actress_ids,
    }
    
    return [product_data], [relations_data] 


# --------------------------------------------------------------------------
# 5. FANZA API ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
# --------------------------------------------------------------------------

def _safe_extract_single_entity(item_info_content: dict, key: str) -> tuple[str | None, str | None]:
    data = item_info_content.get(key)
    if not data: return None, None
    if isinstance(data, list):
        if not data: return None, None
        data = data[0]
    if isinstance(data, dict):
        return data.get('name'), data.get('id')
    elif isinstance(data, str):
        return data, None
    return None, None

def normalize_fanza_data(raw_instance: RawApiData) -> tuple[list[dict], list[dict]]:
    raw_data = raw_instance.raw_json_data
    try:
        data = json.loads(raw_data) if isinstance(raw_data, str) else raw_data
    except Exception:
        return [], []

    item_list = data.get('result', {}).get('items', [])
    products_data_list = []
    relations_list = []

    for item_info in item_list:
        api_raw_id = item_info.get('content_id') or item_info.get('product_id') or item_info.get('id')
        if not api_raw_id: continue

        item_info_content = item_info.get('iteminfo', {})
        maker_name, maker_api_id = _safe_extract_single_entity(item_info_content, 'maker')
        maker_id = get_or_create_entity(Maker, 'FANZA', maker_name, maker_api_id)

        label_name, label_api_id = _safe_extract_single_entity(item_info_content, 'label')
        label_id = get_or_create_entity(Label, 'FANZA', label_name, label_api_id)

        series_name, series_api_id = _safe_extract_single_entity(item_info_content, 'series')
        series_id = get_or_create_entity(Series, 'FANZA', series_name, series_api_id)

        director_name, director_api_id = _safe_extract_single_entity(item_info_content, 'director')
        director_id = get_or_create_entity(Director, 'FANZA', director_name, director_api_id)

        product_id_unique = generate_product_unique_id('FANZA', api_raw_id)
        
        try:
            price = int(item_info.get('price')) if item_info.get('price') else None
        except Exception: price = None

        sample_images = item_info.get('sample_image_urls', {})
        image_url_list = sample_images.get('sample', []) if isinstance(sample_images, dict) else []
        image_url_json = json.dumps(image_url_list) if image_url_list else "[]"
        
        affiliate_url = item_info.get('affiliate_url')
        
        product_data = {
            'raw_data_id': raw_instance.id, 
            'maker_id': maker_id,
            'label_id': label_id,
            'series_id': series_id,
            'director_id': director_id,
            'api_source': 'FANZA',
            'product_id_unique': product_id_unique,
            'title': item_info.get('title'),
            'affiliate_url': affiliate_url if affiliate_url is not None else "",
            'price': price,
            'release_date': parse_date(item_info.get('date') or item_info.get('release_date')), 
            'image_url_list': image_url_json,
            'updated_at': datetime.now(), 
            'created_at': datetime.now(), 
        }

        actress_ids = []
        actress_info = item_info_content.get('actress', [])
        if isinstance(actress_info, list):
            for a in actress_info:
                if isinstance(a, dict) and 'name' in a:
                    aid = get_or_create_entity(Actress, 'FANZA', a['name'], a.get('id'))
                    if aid: actress_ids.append(aid)
        
        genre_ids = []
        genre_info = item_info_content.get('genre', [])
        if isinstance(genre_info, list):
            for g in genre_info:
                if isinstance(g, dict) and 'name' in g:
                    gid = get_or_create_entity(Genre, 'FANZA', g['name'], g.get('id'))
                    if gid: genre_ids.append(gid)

        relations = {
            'api_product_id': api_raw_id,
            'genre_ids': genre_ids,
            'actress_ids': actress_ids,
        }

        products_data_list.append(product_data)
        relations_list.append(relations)
            
    return products_data_list, relations_list